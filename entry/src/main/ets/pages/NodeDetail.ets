import { router } from '@kit.ArkUI';
import { common } from '@kit.AbilityKit';
import { buffer } from '@kit.ArkTS';

// ============== æ¥å£å®šä¹‰ ==============

interface Document {
  file: string;
  title: string;
  type: string;
  display_order: number;
  highlight_sections?: Array<string>;
}

interface GraphNode {
  id: string;
  title: string;
  level: number;
  category: string;
  icon: string;
  color: string;
  status: string;
  estimated_time: string;
  prerequisites: Array<string>;
  documents: Array<Document>;
  summary: string;
  key_points: Array<string>;
  caution?: string;
}

@Entry
@Component
struct NodeDetail {
  private context = getContext(this) as common.Context;

  @State nodeData: GraphNode | null = null;
  @State hasLoaded: boolean = false;
  @State completedDocs: Set<string> = new Set();
  @State expandedDocs: Set<string> = new Set();
  @State documentContents: Record<string, string> = {};

  aboutToAppear(): void {
    this.loadNodeData();
  }

  private loadNodeData(): void {
    const params = router.getParams() as Record<string, Object>;
    if (params && params['nodeData']) {
      try {
        this.nodeData = JSON.parse(params['nodeData'] as string) as GraphNode;
        this.hasLoaded = true;
        // åŠ è½½æ–‡æ¡£å†…å®¹
        this.loadDocumentContents();
      } catch (err) {
        console.error('Failed to parse node data: ' + JSON.stringify(err));
      }
    }
  }

  private async loadDocumentContents(): Promise<void> {
    if (!this.nodeData) return;

    for (const doc of this.nodeData.documents) {
      const content = await this.loadDocument(doc.file);
      if (content) {
        this.documentContents[doc.file] = content;
      }
    }
  }

  private async loadDocument(fileName: string): Promise<string | null> {
    try {
      // æ³¨æ„ï¼šå®é™…æ–‡æ¡£åº”æ”¾åœ¨ rawfile/study_docs/ ç›®å½•ä¸‹
      const value = await this.context.resourceManager.getRawFileContent(`study_docs/${fileName}`);
      const str = buffer.from(value.buffer).toString();
      return this.optimizeMarkdownContent(str);
    } catch (err) {
      console.error('Failed to load document: ' + fileName + ', error: ' + JSON.stringify(err));
      return 'æ–‡æ¡£å†…å®¹åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶è·¯å¾„ã€‚';
    }
  }

  private optimizeMarkdownContent(markdown: string): string {
    // ç®€åŒ–ç‰ˆä¼˜åŒ–ï¼šæå–æ ¸å¿ƒå†…å®¹
    // å®é™…é¡¹ç›®ä¸­å¯ä»¥ä½¿ç”¨ Markdown è§£æåº“
    let optimized = markdown;

    // ç§»é™¤è¿‡å¤šç©ºè¡Œ
    optimized = optimized.replace(/\n{3,}/g, '\n\n');

    // é«˜äº®æ ¸å¿ƒå£è¯€ï¼ˆä»¥ > å¼€å¤´çš„å¼•ç”¨å—ï¼‰
    optimized = optimized.replace(/^> (.+)$/gm, '**ã€å£è¯€ã€‘** $1');

    return optimized;
  }

  private toggleDocExpand(fileName: string): void {
    if (this.expandedDocs.has(fileName)) {
      this.expandedDocs.delete(fileName);
    } else {
      this.expandedDocs.add(fileName);
    }
  }

  private markDocCompleted(fileName: string): void {
    this.completedDocs.add(fileName);
    // å®é™…åº”ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
  }

  build() {
    Column() {
      // é¡¶éƒ¨å¯¼èˆªæ 
      Row() {
        Image($r('app.media.app_icon'))
          .width(32)
          .height(32)
          .margin({ right: 12 })
          .onClick(() => {
            router.back();
          })

        Column() {
          Text(this.nodeData?.title || 'èŠ‚ç‚¹è¯¦æƒ…')
            .fontSize(18)
            .fontWeight(FontWeight.Bold)
            .fontColor('#333333')

          Text(`é¢„è®¡å­¦ä¹ ï¼š${this.nodeData?.estimated_time || ''}`)
            .fontSize(12)
            .fontColor('#999999')
            .margin({ top: 2 })
        }
        .alignItems(HorizontalAlign.Start)

        Blank()
      }
      .width('100%')
      .padding({ left: 20, right: 20, top: 12, bottom: 12 })
      .backgroundColor('#ffffff')
      .border({ width: { bottom: 1 }, color: '#e0e0e0' })

      if (this.hasLoaded && this.nodeData) {
        Scroll() {
          Column() {
            // å­¦ä¹ è¿›åº¦å¡ç‰‡
            Column() {
              Row() {
                Text('ğŸ“Š å­¦ä¹ è¿›åº¦')
                  .fontSize(16)
                  .fontWeight(FontWeight.Medium)
                  .fontColor('#333333')

                Blank()

                Text(`${this.completedDocs.size}/${this.nodeData.documents.length} æ–‡æ¡£å·²å®Œæˆ`)
                  .fontSize(14)
                  .fontColor('#2d8a4e')
              }
              .width('100%')

              Progress({
                value: this.completedDocs.size,
                total: this.nodeData.documents.length,
                type: ProgressType.Linear
              })
                .width('100%')
                .color('#2d8a4e')
                .margin({ top: 12 })
            }
            .width('100%')
            .padding(16)
            .backgroundColor('#ffffff')
            .borderRadius(12)
            .shadow({ radius: 4, color: '#00000010' })

            // èŠ‚ç‚¹æ‘˜è¦
            Column() {
              Text('ğŸ“ æ ¸å¿ƒæ‘˜è¦')
                .fontSize(16)
                .fontWeight(FontWeight.Medium)
                .fontColor('#333333')
                .margin({ bottom: 12 })

              Text(this.nodeData.summary)
                .fontSize(14)
                .fontColor('#666666')
                .lineHeight(22)
            }
            .width('100%')
            .padding(16)
            .backgroundColor('#ffffff')
            .borderRadius(12)
            .margin({ top: 16 })
            .shadow({ radius: 4, color: '#00000010' })

            // å…³é”®è¦ç‚¹
            Column() {
              Text('ğŸ”‘ å…³é”®è¦ç‚¹')
                .fontSize(16)
                .fontWeight(FontWeight.Medium)
                .fontColor('#333333')
                .margin({ bottom: 12 })

              ForEach(this.nodeData.key_points, (point: string, index: number) => {
                Row() {
                  Text(`${index + 1}.`)
                    .fontSize(14)
                    .fontColor('#3d6b4f')
                    .fontWeight(FontWeight.Bold)
                    .margin({ right: 8 })

                  Text(point)
                    .fontSize(14)
                    .fontColor('#666666')
                    .layoutWeight(1)
                    .lineHeight(22)
                }
                .width('100%')
                .alignItems(VerticalAlign.Top)
                .margin({ bottom: index < this.nodeData!.key_points.length - 1 ? 8 : 0 })
              }, (point: string, index: number) => `key_point_${index}`)
            }
            .width('100%')
            .padding(16)
            .backgroundColor('#ffffff')
            .borderRadius(12)
            .margin({ top: 16 })
            .shadow({ radius: 4, color: '#00000010' })

            // è­¦ç¤ºæç¤ºï¼ˆå¦‚æœæœ‰ï¼‰
            if (this.nodeData.caution) {
              Column() {
                Row() {
                  Text('âš ï¸')
                    .fontSize(20)
                    .margin({ right: 8 })

                  Text(this.nodeData.caution)
                    .fontSize(14)
                    .fontColor('#b45309')
                    .layoutWeight(1)
                    .lineHeight(22)
                }
                .width('100%')
              }
              .width('100%')
              .padding(16)
              .backgroundColor('#fff3e0')
              .borderRadius(12)
              .margin({ top: 16 })
              .border({ width: 1, color: '#b45309' })
            }

            // æ–‡æ¡£åˆ—è¡¨
            Column() {
              Text('ğŸ“š å­¦ä¹ æ–‡æ¡£')
                .fontSize(16)
                .fontWeight(FontWeight.Medium)
                .fontColor('#333333')
                .margin({ bottom: 16 })

              ForEach(this.nodeData.documents, (doc: Document) => {
                this.DocumentCard(doc)
              }, (doc: Document) => doc.file)
            }
            .width('100%')
            .padding(16)
            .backgroundColor('#ffffff')
            .borderRadius(12)
            .margin({ top: 16, bottom: 20 })
            .shadow({ radius: 4, color: '#00000010' })

          }
          .width('100%')
          .padding({ left: 20, right: 20, top: 16 })
        }
        .layoutWeight(1)
        .scrollBar(BarState.Auto)

      } else {
        Column() {
          LoadingProgress()
            .width(40)
            .height(40)
            .color('#3d6b4f')
          Text('åŠ è½½èŠ‚ç‚¹è¯¦æƒ…...')
            .fontSize(14)
            .fontColor('#666666')
            .margin({ top: 12 })
        }
        .width('100%')
        .layoutWeight(1)
        .justifyContent(FlexAlign.Center)
      }
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#f8f8f8')
  }

  @Builder
  DocumentCard(doc: Document) {
    Column() {
      // æ–‡æ¡£æ ‡é¢˜æ 
      Row() {
        Text(this.getDocTypeIcon(doc.type))
          .fontSize(20)
          .margin({ right: 8 })

        Column() {
          Text(doc.title)
            .fontSize(15)
            .fontWeight(FontWeight.Medium)
            .fontColor('#333333')

          Text(doc.type === 'rule' ? 'è§„åˆ™' : doc.type === 'formula' ? 'å£è¯€' : 'ç†è®º')
            .fontSize(12)
            .fontColor('#999999')
            .margin({ top: 2 })
        }
        .alignItems(HorizontalAlign.Start)
        .layoutWeight(1)

        // å±•å¼€/æ”¶èµ·æŒ‰é’®
        Text(this.expandedDocs.has(doc.file) ? 'â–²' : 'â–¼')
          .fontSize(14)
          .fontColor('#666666')
      }
      .width('100%')
      .padding(12)
      .backgroundColor(this.completedDocs.has(doc.file) ? '#e8f5e9' : '#f5f5f5')
      .borderRadius(8)
      .onClick(() => {
        this.toggleDocExpand(doc.file);
      })

      // æ–‡æ¡£å†…å®¹ï¼ˆå±•å¼€æ—¶æ˜¾ç¤ºï¼‰
      if (this.expandedDocs.has(doc.file)) {
        Column() {
          if (this.documentContents[doc.file]) {
            Text(this.documentContents[doc.file])
              .fontSize(14)
              .fontColor('#555555')
              .lineHeight(24)
              .margin({ top: 12, bottom: 12 })
          } else {
            Text('åŠ è½½ä¸­...')
              .fontSize(14)
              .fontColor('#999999')
              .margin({ top: 12, bottom: 12 })
          }

          // æ“ä½œæŒ‰é’®
          Row() {
            Button(this.completedDocs.has(doc.file) ? 'âœ“ å·²å®Œæˆ' : 'æ ‡è®°å·²å­¦')
              .fontSize(14)
              .backgroundColor(this.completedDocs.has(doc.file) ? '#2d8a4e' : '#3d6b4f')
              .fontColor('#ffffff')
              .borderRadius(8)
              .padding({ left: 16, right: 16, top: 8, bottom: 8 })
              .onClick(() => {
                this.markDocCompleted(doc.file);
              })

            Button('ğŸ“ æ·»åŠ ç¬”è®°')
              .fontSize(14)
              .backgroundColor('#f0f0f0')
              .fontColor('#333333')
              .borderRadius(8)
              .padding({ left: 16, right: 16, top: 8, bottom: 8 })
              .margin({ left: 12 })
              .onClick(() => {
                // æ‰“å¼€ç¬”è®°ç¼–è¾‘å™¨
              })
          }
          .width('100%')
        }
        .width('100%')
        .padding(12)
      }
    }
    .width('100%')
    .margin({ bottom: 12 })
  }

  private getDocTypeIcon(type: string): string {
    if (type === 'rule') return 'ğŸ“‹';
    if (type === 'formula') return 'ğŸ“¿';
    if (type === 'theory') return 'ğŸ“–';
    if (type === 'method') return 'ğŸ”§';
    if (type === 'classic') return 'ğŸ“œ';
    if (type === 'reference') return 'ğŸ“š';
    if (type === 'special') return 'â­';
    return 'ğŸ“„';
  }
}
